/*
 * Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
 * See LICENSE in the project root for license information.
 */
/* global document, Office, Word */

//require("./keyhandling.js");
const gptApi = require("./GPT_API.js");
//require(fetch);

const KEYITEM_NAME = "GPTAPI_Key";

const GPT_MODEL_DAVINCI = "davinci";
const GPT_MODEL_GPT3_5_TURBO = "gpt-3.5-turbo";

Office.onReady(async (info) => {
  if (info.host === Office.HostType.Word) {
    document.getElementById("sideload-msg").style.display = "none";
    document.getElementById("app-body").style.display = "flex";

    document.getElementById("BtnAddText").onclick = addTextToSelection;
    document.getElementById("BtnCorrectText").onclick = correctSelection;
    document.getElementById("BtnTranslate").onclick = translateSelection;
    document.getElementById("BtnSummarizeText").onclick = summarizeSelection;
    document.getElementById("BtnComplexityText").onclick = rewriteSelection;

    document.getElementById("btnCustomPrompt").onclick = executeCustomTask;
    document.getElementById("btnQuestion").onclick = answerQuestion;

    document.getElementById("BtnApiKeyReset").onclick = removeGPTKey;
    document.getElementById("BtnApiKeyConfirm").onclick = addGPTKey;

    await verifyGPTKey();
  }
});

function setApiKeyStatus(makeVisible) {
  document.getElementById("ApiKeyLoading").style.display = "none";
  document.getElementById("IconApiKeyVerified").style.display = makeVisible ? "grid" : "none";
  document.getElementById("IconApiKeyFalse").style.display = makeVisible ? "none" : "grid";

  // display warning text
  //document.getElementById("ErrorMessage").innerText = makeVisible ? "" : "No API key! Please enter your API key.";
}

function setApiKeyStatusLoading() {
  document.getElementById("IconApiKeyVerified").style.display = "none";
  document.getElementById("IconApiKeyFalse").style.display = "none";
  document.getElementById("ApiKeyLoading").style.display = "grid";
}

function showApiCallLoadingGif(makeVisible) {
  document.getElementById("ApiCallLoading").style.display = makeVisible ? "inline" : "none";
}

// --------------------- Selected Text Conversion ---------------------

/**
 * This function is called when the user clicks the "Continue selected text" button.
 * The text will be continued using the GPT API.
 * The generated text will be inserted after the selected text.
 */
export async function addTextToSelection() {
  Word.run(async (context) => {
    var rangeSelected;
    var selectedText;
    var generatedText;
    var chosenFunction;

    showApiCallLoadingGif(true);

    if (await verifyGPTKey()) {
      // Extract selected text
      rangeSelected = context.document.getSelection();
      rangeSelected.load("text");
      await context.sync();
      selectedText = rangeSelected.text;

      // Choose correct API function depending on selected model
      switch (document.getElementById("ApiModel").value) {
        case GPT_MODEL_DAVINCI:
          chosenFunction = gptApi.text_completion_Davinci;
          break;
        case GPT_MODEL_GPT3_5_TURBO:
          chosenFunction = gptApi.text_completion_GPT3;
          break;
        default:
          chosenFunction = gptApi.text_completion_Davinci;
          console.log("No API Model selected");
      }

      // Generate text
      generatedText = await chosenFunction(selectedText, document.getElementById("ApiLanguage").value);

      // Insert generated text
      await embedText(rangeSelected, generatedText, "This text was generated by the GPT API", "");
    }
    showApiCallLoadingGif(false);
  });
}

/**
 * This function is called when the user clicks the "Correct selected text" button.
 * The corrected text will replace the selected text.
 * The original text will be inserted as a comment.
 */
export async function correctSelection() {
  Word.run(async (context) => {
    var rangeSelected;
    var correctedText, selectedText;
    var chosenFunction;

    showApiCallLoadingGif(true);

    if (await verifyGPTKey()) {
      rangeSelected = context.document.getSelection();
      rangeSelected.load("text");
      await context.sync();
      selectedText = rangeSelected.text;

      // Correct Text via GPT API
      switch (document.getElementById("ApiModel").value) {
        case GPT_MODEL_DAVINCI:
          chosenFunction = gptApi.text_correction_Davinci;
          break;
        case GPT_MODEL_GPT3_5_TURBO:
          chosenFunction = gptApi.text_correction_GPT3;
          break;
        default:
          chosenFunction = gptApi.text_correction_Davinci;
          console.log("No API Model selected");
      }

      correctedText = await chosenFunction(selectedText, document.getElementById("ApiLanguage").value);

      // Delete previous selected text
      rangeSelected.clear();
      await context.sync();

      await embedText(
        rangeSelected,
        correctedText,
        "This text was corrected by the GPT API",
        "Original text:\n" + selectedText
      );
    } else {
      console.log("Key not verified");
    }
    showApiCallLoadingGif(false);
  });
}

/**
 * This function is called when the user clicks the "Translate to" button.
 * Depending on the selected language, the selected text will be translated.
 * The translated text will replace the selected text.
 * The original text will be inserted as a comment.
 */
export async function translateSelection() {
  return Word.run(async (context) => {
    var rangeSelected;
    var translatedText, selectedText;
    var chosenFunction;

    showApiCallLoadingGif(true);

    if (await verifyGPTKey()) {
      rangeSelected = context.document.getSelection();
      rangeSelected.load("text");
      await context.sync();
      selectedText = rangeSelected.text;

      switch (document.getElementById("ApiModel").value) {
        case GPT_MODEL_DAVINCI:
          chosenFunction = gptApi.text_translation;
          break;
        case GPT_MODEL_GPT3_5_TURBO:
          chosenFunction = gptApi.text_translation;
          break;
        default:
          chosenFunction = gptApi.text_translation;
          break;
      }

      translatedText = await chosenFunction(
        selectedText,
        document.getElementById("ApiLanguage").value,
        document.getElementById("LanguageTo").value
      );

      // Delete previous selected text
      rangeSelected.clear();
      await context.sync();

      // Process text to fit into the document
      await embedText(
        rangeSelected,
        translatedText,
        "This text was translated by the GPT API",
        "Original text:\n" + selectedText
      );
    } else {
      console.log("Key not verified");
    }
    showApiCallLoadingGif(false);
  });
}

/**
 * This function is called when the user clicks the "Summarize selected text" button.
 * The summarized text is inserted into the document.
 */
export async function summarizeSelection() {
  Word.run(async (context) => {
    var rangeSelected;
    var summarizedText, selectedText;
    var chosenFunction;

    showApiCallLoadingGif(true);

    if (await verifyGPTKey()) {
      rangeSelected = context.document.getSelection();
      rangeSelected.load("text");
      await context.sync();
      selectedText = rangeSelected.text;

      switch (document.getElementById("ApiModel").value) {
        case GPT_MODEL_DAVINCI:
          chosenFunction = gptApi.textSummaryDavinci;
          break;
        case GPT_MODEL_GPT3_5_TURBO:
          chosenFunction = gptApi.textSummaryGpt3;
          break;
        default:
          chosenFunction = gptApi.textSummaryDavinci;
          break;
      }

      summarizedText = await chosenFunction(
        selectedText,
        document.getElementById("ApiLanguage").value,
        document.getElementById("LanguageTo").value
      );

      // Delete previous selected text
      rangeSelected.clear();
      await context.sync();

      // Process text to fit into the document
      await embedText(
        rangeSelected,
        summarizedText,
        "This text was summarized by the GPT API",
        "Original text:\n" + selectedText
      );
    }
    showApiCallLoadingGif(false);
  });
}

/**
 * This function is called when the user clicks the "Rewrite selected text" button.
 * Depending on the chosen option (Simplify/Complexify) the text is rewritten.
 * The rewritten text is then inserted into the document.
 */
export async function rewriteSelection() {
  Word.run(async (context) => {
    var rangeSelected;
    var rewrittenText, selectedText;
    var chosenFunction;

    showApiCallLoadingGif(true);

    if (await verifyGPTKey()) {
      rangeSelected = context.document.getSelection();
      rangeSelected.load("text");
      await context.sync();
      selectedText = rangeSelected.text;

      // Translate Text via GPT API depending on chosen model
      switch (document.getElementById("ApiModel").value) {
        case GPT_MODEL_DAVINCI:
          chosenFunction = gptApi.rewriteTextDavinci;
          break;
        case GPT_MODEL_GPT3_5_TURBO:
          chosenFunction = gptApi.rewriteTextGpt3;
          break;
        default:
          chosenFunction = gptApi.rewriteTextDavinci;
          break;
      }

      rewrittenText = await chosenFunction(
        selectedText,
        document.getElementById("ApiLanguage").value,
        document.getElementById("TextComplexity").value
      );

      // Delete previous selected text
      rangeSelected.clear();

      // Embed text into the document
      await embedText(
        rangeSelected,
        rewrittenText,
        "Text was rewritten by the GPT API",
        "Original text:\n" + selectedText
      );
    }
    showApiCallLoadingGif(false);
  });
}

/**
 * This function is called when the user clicks the "Send Prompt" button.
 * It will send the custom prompt together with the selected text to the GPT API and insert the response into the document.
 * The generated text will be inserted after the selected text.
 */
export async function executeCustomTask() {
  Word.run(async (context) => {
    var rangeSelected;
    var customTaskText, selectedText, requestText;

    showApiCallLoadingGif(true);

    if (await verifyGPTKey()) {
      rangeSelected = context.document.getSelection();
      rangeSelected.load("text");
      await context.sync();
      selectedText = rangeSelected.text;
      var customPrompt = document.getElementById("CustomPrompt").value;

      // Check if custom prompt is empty
      if (customPrompt == "") {
        setErrorMessage("Please enter a custom prompt");
        showApiCallLoadingGif(false);
        return;
      }

      requestText = customPrompt.trim();
      requestText += requestText.slice(-1) == ":" ? "" : ":";
      requestText += " " + selectedText;

      customTaskText = await gptApi.Chatbot(requestText);

      // Insert a newline into the document
      rangeSelected.insertText("\n", "End");

      await embedText(
        rangeSelected,
        customTaskText,
        "This text was generated by the GPT API",
        "Custom prompt:\n" + customPrompt
      );
    } else {
      console.log("Key not verified");
    }
    showApiCallLoadingGif(false);
  });
}

// ------------------CHATBOT-----------------------

/**
 * Answer a question via the GPT API.
 * The question is taken from an input field.
 * The answer is inserted into a text field.
 */

export async function answerQuestion() {
  showApiCallLoadingGif(true);
  var question, answer;

  question = document.getElementById("QuestionText").value;

  // Answer Question via GPT API
  answer = await gptApi.Chatbot(question);

  document.getElementById("QuestionAnswer").value = answer;
  showApiCallLoadingGif(false);
}

// ----------------TEXT-EMBEDDING--------------------

/**
 * Remove all white spaces from a string
 * @param {string} text String to remove white spaces from
 * @returns text without white spaces
 */
function removeWhiteSpaces(text) {
  text = text.replace(/\s+/g, " ").trim();
  return text;
}

/**
 * Insert a space at the end of a range
 * @param {Word.Range} range Word-Range to insert the space into
 * @returns Word-Range including the inserted space
 */
async function insertSpace(range) {
  return Word.run(async (context) => {
    var rangeSpace = range.getRange("end");
    rangeSpace.insertText(" ", Word.InsertLocation.end);
    await context.sync();
    return rangeSpace;
  });
}

/**
 * Insert and embed text into a range and add a footnote and a comment
 * @param {Word.Range} range range that the text will be embedded into
 * @param {String} text text to be embedded
 * @param {String} footnote Insert footnote with this text. If empty, no footnote will be inserted.
 * @param {String} comment Insert comment with this text. If empty, no comment will be inserted.
 * @returns Word.Range including the inserted, embedded text
 */
async function embedText(range, text, footnote = "", comment = "") {
  var insertedTextRange;
  Word.run(async (context) => {
    // Process text to fit into the document
    var processedText = removeWhiteSpaces(text);

    // Insert text
    insertedTextRange = range.insertText(processedText, Word.InsertLocation.end);
    await context.sync();
    range.expandTo(insertedTextRange);
    range.select();
    await context.sync();

    await insertSpace(range);
    await context.sync();

    if (comment != "") {
      // Insert comment displaying original text
      range.insertComment(comment);
      await context.sync();
    }
    if (footnote != "" && document.getElementById("FootnotesBox").checked) {
      range.insertFootnote(footnote);
      await context.sync();
    }

    await insertSpace(range);
    await context.sync();

    return range;
  });
}

// ------------------KEY--------------------------
/**
 * Add the GPT API key to the document and check if it is valid. 
 * If it is valid, the key will be applied and stored in the document.
 * @returns true if the key is valid, false if not
 */
export async function addGPTKey() {
  return Word.run(async (context) => {
    setApiKeyStatusLoading();
    var valid, newKey;
    context.document.properties.customProperties.load("items");
    await context.sync();

    newKey = document.getElementById("ApiKey").value;

    valid = await gptApi.set_key(newKey);
    if (valid) {
      // Key is correct and was applied
      context.document.properties.customProperties.add(KEYITEM_NAME, newKey);
      setApiKeyStatus(true);
      setErrorMessage("");
      console.log("Key applied");
    } else {
      // Error message, wrong key
      console.log("Key denied");
      setErrorMessage("Key is not valid.");
      setApiKeyStatus(false);
    }

    await context.sync();
  });
}

/**
 * Remove the GPT API key from the document
 */
export async function removeGPTKey() {
  Word.run(async (context) => {
    setApiKeyStatusLoading();
    if (await checkGPTKeyExists()) {
      const properties = context.document.properties.customProperties;

      context.document.properties.customProperties.load("items");
      await context.sync();

      properties.getItem(KEYITEM_NAME).delete();

      await context.sync();
      console.log(context.document.properties.customProperties.items);
    } else {
      console.log("No key to remove");
    }
    await verifyGPTKey();
    document.getElementById("ApiKey").value = "";
    setApiKeyStatus(false);
  });
}

/**
 * Check if a valid GPT API key is stored in the document
 * @returns true if a valid stored key exists, false if not
 */
export async function verifyGPTKey() {
  setApiKeyStatusLoading();
  var keyValid = false;
  await Word.run(async (context) => {
    if (await checkGPTKeyExists()) {
      const properties = context.document.properties.customProperties;

      var gpt_key = properties.getItem(KEYITEM_NAME);

      gpt_key.load("value");
      await context.sync();

      var chosen_key = gpt_key.value;

      console.log("read key: " + chosen_key);
      if (await gptApi.set_key(chosen_key)) {
        console.log("Key is valid");
        keyValid = true;
        document.getElementById("ApiKey").value = chosen_key;
        setErrorMessage("");
      } else {
        console.log("Key is not valid");
        setErrorMessage("Key is not valid");
      }
    } else {
      console.log("No key available");
      setErrorMessage("No key available");
    }
    await context.sync();
  });
  setApiKeyStatus(keyValid);
  return keyValid;
}

/**
 * Check if a key exists in the document
 * @returns true if a key exists in the document, false if not
 */
export async function checkGPTKeyExists() {
  var keyExists = false;
  await Word.run(async (context) => {
    const properties = context.document.properties.customProperties;

    context.document.properties.customProperties.load("items");
    properties.load("key");
    await context.sync();

    for (var i = 0; i < properties.items.length; i++) {
      if (properties.items[i].key === KEYITEM_NAME) {
        keyExists = true;
        break;
      }
    }
  });
  return keyExists;
}

export async function setErrorMessage(message) {
  document.getElementById("ErrorMessage").innerText = message;
}
